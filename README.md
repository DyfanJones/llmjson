# llmjson

<!-- badges: start -->
[![R-CMD-check](https://github.com/DyfanJones/llmjson/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/DyfanJones/llmjson/actions/workflows/R-CMD-check.yaml)
[![Codecov test coverage](https://codecov.io/gh/DyfanJones/llmjson/graph/badge.svg)](https://app.codecov.io/gh/DyfanJones/llmjson)
[![R-universe version](https://DyfanJones.r-universe.dev/llmjson/badges/version)](https://DyfanJones.r-universe.dev/llmjson)
<!-- badges: end -->

`llmjson` repairs malformed JSON strings, particularly those generated by Large Language Models (LLMs). It uses Rust for fast, reliable JSON repair based on a vendored and bug-fixed version of the [llm_json](https://github.com/oramasearch/llm_json) crate.

## Features

- Repairs missing quotes around keys and values
- Handles trailing commas
- Fixes unquoted keys
- Repairs incomplete arrays and objects
- Converts single quotes to double quotes
- Removes extra non-JSON characters
- Auto-completes missing values with sensible defaults
- Returns R objects directly with `return_objects = TRUE`
- Schema validation and type conversion with intuitive schema builders
- Control field presence with `.optional` and use `.default` for required fields

## Installation

You can install the development version of llmjson from GitHub:

``` r
# install.packages("remotes")
remotes::install_github("DyfanJones/llmjson")
```

Or r-universe:
```r
install.packages('llmjson', repos = c('https://dyfanjones.r-universe.dev', 'https://cloud.r-project.org'))
```

### System Requirements

This package requires the Rust toolchain to be installed on your system. If you don't have Rust installed:

- Install from <https://www.rust-lang.org/tools/install>
- Minimum required version: Rust 1.65.0

## Usage

### Basic JSON Repair

``` r
library(llmjson)

# Repair JSON with trailing comma
repair_json_str('{"key": "value",}')
#> [1] "{\"key\":\"value\"}"

# Repair JSON with unquoted keys
repair_json_str('{key: "value"}')
#> [1] "{\"key\":\"value\"}"

# Repair incomplete JSON
repair_json_str('{"name": "John", "age": 30')
#> [1] "{\"name\":\"John\",\"age\":30}"

# Repair JSON with single quotes
repair_json_str("{'name': 'John'}")
#> [1] "{\"name\":\"John\"}"
```

### Return R Objects Directly

Instead of returning a JSON string, you can get R objects directly:

``` r
# Return as R list instead of JSON string
result <- repair_json_str('{"name": "Alice", "age": 30}', return_objects = TRUE)
result
#> $name
#> [1] "Alice"
#>
#> $age
#> [1] 30

# Works with all repair functions
result <- repair_json_file("data.json", return_objects = TRUE)
```

### Schema Validation and Type Conversion

Define schemas to validate JSON structure and ensure correct R types. The schema system is inspired by the [structr](https://github.com/ixpantia/structr) package and provides an intuitive way to define expected JSON structures:

``` r
# Define a schema for a user object
schema <- s_map(
  name = s_string(),
  age = s_integer(),
  email = s_string()
)

# Repair and validate with schema
result <- repair_json_str(
  '{"name": "Alice", "age": "30", "email": "alice@example.com"}',
  schema = schema,
  return_objects = TRUE
)

# Note: age is coerced from string "30" to integer 30
str(result)
#> List of 3
#>  $ name : chr "Alice"
#>  $ age  : int 30
#>  $ email: chr "alice@example.com"
```

### Optional Fields and Default Values

Control how missing fields are handled with `.optional` and `.default` parameters:

**Required fields** (`.optional = FALSE`, the default):
- Missing fields are added with their `.default` value (or `null` if no default)
- Always appear in the output

**Optional fields** (`.optional = TRUE`):
- Missing fields are omitted entirely from the output
- Only appear if present in the input JSON

``` r
# Example 1: Required field with default
schema <- s_map(
  name = s_string(),
  age = s_integer(.default = 25L)  # required, will use default if missing
)

result <- repair_json_str('{"name": "Alice"}', schema = schema, return_objects = TRUE)
result
#> $name
#> [1] "Alice"
#>
#> $age
#> [1] 25

# Example 2: Optional field (omitted when missing)
schema <- s_map(
  name = s_string(),
  nickname = s_string(.optional = TRUE)  # optional, omitted if not in input
)

result <- repair_json_str('{"name": "Bob"}', schema = schema, return_objects = TRUE)
result
#> $name
#> [1] "Bob"
# Note: nickname is not present since it was optional and missing from input

# Example 3: Required field without default (gets null)
schema <- s_map(
  name = s_string(),
  email = s_string()  # required, no default specified
)

result <- repair_json_str('{"name": "Charlie"}', schema = schema, return_objects = TRUE)
result
#> $name
#> [1] "Charlie"
#>
#> $email
#> NULL
```

### Nested Schemas and Arrays

Build complex schemas with nested objects and arrays:

``` r
# Schema with nested object and array
schema <- s_map(
  name = s_string(),
  address = s_map(
    city = s_string(),
    zip = s_integer()
  ),
  scores = s_array(s_integer())
)

json_str <- '{
  "name": "Alice",
  "address": {"city": "NYC", "zip": "10001"},
  "scores": [90, 85, 95]
}'

result <- repair_json_str(json_str, schema = schema, return_objects = TRUE)
str(result)
#> List of 3
#>  $ name   : chr "Alice"
#>  $ address:List of 2
#>   ..$ city: chr "NYC"
#>   ..$ zip : int 10001
#>  $ scores : int [1:3] 90 85 95
```


### Build Schemas for Better Performance

For repeated use with the same schema, use `build_schema()` to compile the schema once and reuse it many times.

``` r
# Define your schema
schema <- s_map(
  name = s_string(),
  age = s_integer(),
  email = s_string()
)

# Build it once - this creates an optimized internal representation
built_schema <- build_schema(schema)

# Reuse many times - much faster!
for (json_str in json_strings) {
  result <- repair_json_str(json_str, built_schema, return_objects = TRUE)
  # Process result...
}
```

**Performance comparison** (complex nested schema):
- Without `build_schema()`: ~266µs per call
- With `build_schema()`: ~51µs per call (**5.2x faster**)
- No schema: ~44µs per call

The performance benefit is especially significant for:
- Complex nested schemas with multiple levels
- Batch processing of many JSON strings
- Performance-critical applications
- Real-time data processing pipelines

### Repair JSON from Files

``` r
# Read and repair JSON from a file
repair_json_file("malformed.json")

# With schema validation
schema <- s_map(
  name = s_string(),
  age = s_integer(.default = 25L)  # required field with default
)
result <- repair_json_file("data.json", schema = schema, return_objects = TRUE)
```

### Repair JSON from Raw Bytes

``` r
# Repair JSON from raw byte vector
raw_data <- charToRaw('{"key": "value",}')
repair_json_raw(raw_data)
#> [1] "{\"key\":\"value\"}"

# With return_objects
result <- repair_json_raw(raw_data, return_objects = TRUE)
```

## Use Case: Working with LLM Outputs

Large Language Models often generate JSON that is almost correct but has minor syntax errors. This package helps you handle those cases gracefully:

``` r
# LLM might output JSON with trailing commas and unquoted keys
llm_output <- '{
  users: [
    {name: "Alice", age: 30,},
    {name: "Bob", age: 25,},
  ],
}'

# Option 1: Repair and parse with your chosen JSON parser (e.g., jsonlite)
repaired <- repair_json_str(llm_output)
(parsed <- jsonlite::fromJSON(repaired))
#> $users
#>   age  name
#> 1  30 Alice
#> 2  25   Bob

# Option 2: Use schema with return_objects for type safety
schema <- s_map(
  users = s_array(s_map(
    name = s_string(),
    age = s_integer()
  ))
)

result <- repair_json_str(llm_output, schema = schema, return_objects = TRUE)
str(result)
#> List of 1
#>  $ users:List of 2
#>   ..$ :List of 2
#>   .. ..$ name: chr "Alice"
#>   .. ..$ age : int 30
#>   ..$ :List of 2
#>   .. ..$ name: chr "Bob"
#>   .. ..$ age : int 25
```

## Available Functions

### Repair Functions

All repair functions support the `schema`, `return_objects`, and `ensure_ascii` parameters:

- **`repair_json_str(json_str, schema = NULL, return_objects = FALSE, ensure_ascii = TRUE)`** - Repair a malformed JSON string
- **`repair_json_file(path, schema = NULL, return_objects = FALSE, ensure_ascii = TRUE)`** - Read and repair JSON from a file
- **`repair_json_raw(raw_bytes, schema = NULL, return_objects = FALSE, ensure_ascii = TRUE)`** - Repair JSON from a raw byte vector

**Parameters:**
- `schema` - Optional schema definition (R list from `s_map()`, etc.) or built schema (from `build_schema()`)
- `return_objects` - If `TRUE`, returns R objects instead of JSON strings
- `ensure_ascii` - If `TRUE` (default), escape non-ASCII characters in the output JSON

### Schema Functions

- **`build_schema(schema)`** - Compile a schema definition for efficient reuse (5x performance improvement)
- **`s_map(..., .optional)`** - Define a JSON object with named fields
- **`s_integer(.optional, .default)`** - Integer field with optional defaults
- **`s_double(.optional, .default)`** - Double/numeric field with optional defaults
- **`s_string(.optional, .default)`** - String field with optional defaults
- **`s_logical(.optional, .default)`** - Logical/boolean field with optional defaults
- **`s_date(.optional, .default, .format)`** - Date field with format specification
- **`s_posixct(.optional, .default, .format, .tz)`** / **`s_timestamp()`** - POSIXct datetime field
- **`s_array(items, .optional)`** - Array with specified item type
- **`s_any(.optional)`** - Accept any JSON type

## Comparison with Similar Packages

While R has several JSON parsing packages like `jsonlite`, they typically fail when encountering malformed JSON. `llmjson` is specifically designed to handle the common errors that LLMs make when generating JSON output, making it ideal for:

- Processing LLM API responses
- Parsing structured data from AI-generated text
- Building robust data pipelines with LLM integrations
- Working with JSON data from web scraping or unreliable sources

## Acknowledgments

This package includes a vendored and bug-fixed version of the [llm_json](https://github.com/oramasearch/llm_json) Rust crate (v1.0.1) by Ribelo, which is itself a Rust port of the Python [json_repair](https://github.com/mangiucugna/json_repair) library by Stefano Baccianella (mangiucugna). Our vendored version includes critical bug fixes for array parsing not present in the upstream release.

The schema system was inspired by the [structr](https://github.com/ixpantia/structr) package, which provides elegant patterns for defining and validating data structures in R.

## Code of Conduct

Please note that the llmjson project is released with a [Contributor Code of Conduct](https://contributor-covenant.org/version/2/1/CODE_OF_CONDUCT.html). By contributing to this project, you agree to abide by its terms.
